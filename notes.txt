By default all components in app directory are server components.
In server components the component is rendered on the server side and the data which is fetched by api is also cached.
Benifits -
Data fetching happens on server side.
Can keep sensitive data on server components like token, api keys.
caching
bundle sizes
initial page load
SEO
streaming.

Static Rendering(Next 13) Replaced with getStaticProps(Next 12)
Dynamic Rendering(Next 13) Replaced with getServerSideProps(Next 12)

By default all the server components are rendered staticly.
Means it will compile the project and cached the data on the server and after that if we request data again it will give cached version rather than fetching data again.

In Dynamic Rendering Routes are rendered for each user at a request time
(Here we prevent caching)



Caching - 

const response = await fetch('http://localhost:3000/api/rooms');

Next js extends native fetch method so we can configure the behaviour of caching and revalidating.
We can fetch data in server components only.

We've done console.log("Rooms per page => ", rooms.resultsPerPage); => output will be Rooms per page 4
Now if we go to controller file in room controller and change the value of resultsPerPage it will not reflect here it will be still 4 because Next JS serving us the cached version of data.

So we are not getting the data dynamically from the backend on each request.

If data doesn't change frequently we can use caching.
If data changes frequently we can override the caching behaviour.


const response = await fetch('http://localhost:3000/api/rooms',{cache:'no-cache'});

What is caching
Caching stores data so it doesn't need to be refetched from backend on every request.
So If next time user makes request the cached data will be return.

By default behaviour is "force-cache"
We can override this using "no-cache" or "no-store"


Revalidation - Revalidation means we clear the cache and fetch the new data.
We can do it in 2 different ways
1. Time-based Revalidation - We specify the time. Eg. After each 10mins refetch the data.

 const response = await fetch('http://localhost:3000/api/rooms',{next:{
    revalidate:10
  }});

  now to see - add console in comp and change the value of resultsPerPage. 
  And if we refresh the page immediately it will still show previous value.
  And if we refresh after 10 seconds 1st time the previous vlaue will come but from 2nd time the new value will come.

  if we pass revaliidate: 0
  In this case it will not store any cache.


2. On-demand Revalidation - When we want to refetch the data. We pass a collection name in it. w'll use if for update room. After updating the room we'll say refetch the data.



// PAGINATION

1. we installed package for pagination.
2. Got the page number from url search params and default it'll be 1.
const searchParams = useSearchParams();
const page = Number(searchParams.get("page")) || 1;
// useSearchParams() -> gives us the url params.
e.g https://google.com?page=3
In this case it will give us {page : 3}
We have pass active page to the <Pagination /> component bcz it need that for active styling.

3. We called this comp in Home Comp and pass the resPerPage and filteredRoomsCount.
// We need to pass this to <Pagination />

3. handleChange function which will be called after changing the page by clicking on the page number; And will have the access to the number which user has clicked.

In this function we want if we click on the page number we want to add that in the query. So we'll use this to fetch the data from backend accordingly.

So 1st we checked window should not be undefined Means page is loaded properly

We can't use the searchParams.set() to set the params we have to use class URLSeaerchParams
We have passed window.location.search to it so  -  it will create a new URLSearchParams object that represents the key-value pairs in the query string.

//Now we want to check if there is a "page" in query then update it with this new page value.
If not set then add it in query
e.g http://localhost:300?page=2 - > already there and user clicks 4 it will be http://localhost:300?page=4
e.g http://localhost:3000 -> not there and user clicks on 2 http://localhost:300?page=2

If the URLSearchParams object is showing { size: 2 } and you've confirmed that your URL is correctly formatted, then it indicates that the forEach loop should work correctly. The { size: 2 } output itself is expected when you log the URLSearchParams object directly, as it doesn't show the individual key-value pairs in the console.
If you want to see you can use forEach method of URLSeaerchParams class.

 we have added the query now we want to push the user to that url.

 const path = `window.location.pathname?${queryParams.toString()}`  - It will convert that to string to show in query.
 and just
 router.push(path);

 Now we want to get the value from query and pass that to backend.
so we are pushing the user to home page bcz the url will be same only params will be change.
In HomePage will get the {searchParams} which will be string and will pass this to the getRoomsData function.

In thw getRoomsData we've again used URLSeaerchParams bcz are getting Object of queryParams - 
{ page: '2' }

and we've passed this so URLSeaerchParams will convert it to query string.
 { 'page' => '2' } 

and that queryString we will convert to actual string so 
page=2

and at the end url will be 
${process.env.API_URL}/api/rooms?page=2 -> And logic for this we've handled in backend


// FILTERS

1. Location 
// We have input field for the location we'll get the value from that field and push that to the url.
// In handleSubmit
We push the user to 
router.push(`/?location=${location}`) so It'll call the api and it will show the data accordingly. We've logic in backend for the same.

Then We updated the code to -  
 // It'll filter out the locations which has no value
        const queryString = [location && `location=${location}`,numOfGuests && `guestCapacity=${numOfGuests}`,roomType && `category=${roomType}`].filter(Boolean).join("&");

So it'll add the queryParams based on the condition.
.filter(Boolean) It will remove all false values.


// REGISTER THE USER - 

1ST we created controller for it and we called that controller in the register api route.

// NEXT AUTH

We called SignIn fn in Login component and that wll come to this file [...nextauth]/route.ts
And it'll see the provider name in this case 'credentials' and will handle it accordingly.


session: and strategy which we will be using for authentication which will be "jwt"

Now there are providers array in this we define what type of providers we will be using 
e.g Github 
google
instagram etc 
and we are using CredentialsProvider

in CredentialsProvider we have authorize function in this we get the access to credentials.
so we destructed the email and password of the user to check in db is that user is present or not.

After this we returned the user;

Callbacks.

Now we have some callbacks in nextAuth 
Callbacks are asynchfonous functions we can use to control what happens when action is performed.

// We've to add the user in the session. so will use some callbacks e.g jwt and session

jwt: async({token,user}) => {
            if(user) {
                token.user = user;
            }

            // TODO : Update session when user is updated.
            return token;
        },
this callback is called when JWT is created or updated.
in this fn we get the access to token and the user which we are returning from authorize();

Now we want to store the user in session so we'll write the session callback in that we'll get the session and the token which we are returning from the jwt.

session: async({session,token}) => {
            session.user = token.user as IUser;

            return session;
        }

        We have stored the user in token already in jwt callback so we are saving the user in session.user as well.

// And at the end we added secret key 


// Showing username in header

So we'll get user session and in that we'll have user details and we'll show it in header.

1st we need to wrap our application in SessionProvider so we did that in Global provider

then in header we'll use useSession hook to get the session. 
And when we wrap our app in session provider it'll also call the session callback in [...nextauth]/route.ts

// Logout 
for logout nextauth provoides us signOut() functoijn we can call that to signout.

//Skeleton on loading

If we refresh the page the data which is coming from session will be undefined, and once session is loaded the data will have the user value.
so we want to show the skeleton if data is undefined.

//Redux toolkit query
1st Create a store using configureStore();
Wrap the application using Provider.
create custom hooks for useDispatch and useSelector. 
// * @use - Using these custom hooks avoids repeating type definitions for useDispatch and useSelector in multiple places.


//Slices
//Slice - Slice is a collection of your reducer logic and actions.

//We created userSlice 
and in this we defined initial state for the user slice and also reducers
setUser and setIsAuthenticated
We'll dispatch this and it'll updated our state.

We've exorted reducer bcz we want to use that in store and in store we have given the name to it 'auth'.
And whenever we need user data we'll call useSelector() and take state.auth so it'll give the user data.
And also exported dispatch to dispatch the actions.
And we've set the user in header.tsx


// Redux toolkit query
This is used to get the data and to cache the data but we are not using this feature of the RTK query, we'll use it to register the user.

If we want to send the data to backend means POST request then we use Mutation
And If we want to get the data we use query


// Using Redux Toolkit Query and creating an API with createApi provides several benefits even if you can directly call the register API. Here are some reasons why you might want to use it:

// Redux Integration: It seamlessly integrates with Redux, allowing you to store API data in the Redux store. This makes it easy to manage and share data across components.
Means - When you make an API call, RTK Query handles the response and automatically stores the data in the Redux store.
For example, when you call register(data), RTK Query will manage the API request, receive the response, and store relevant data in the Redux store.

// State Management: Redux Toolkit Query handles the caching, invalidation, and re-fetching of data for you. This can significantly simplify the state management of your application.

// Slices: It automatically creates Redux slices for your API endpoints, reducing the need for manually writing actions, reducers, and selectors.

// Normalization: It normalizes data by default, making it easy to update parts of your Redux store without duplicating data.

// Generated Hooks: It generates hooks for each endpoint, like useRegisterMutation in your case. These hooks handle dispatching actions and managing loading states.

// Consistency and Convention: It follows conventions and best practices, promoting a consistent and organized approach to handling API requests.

// Middleware: It allows you to add middleware, such as authentication checks, easily

/* We used createApi to create api,  
reducerPath: "authApi", RTK query automatically creates slices for api endpoiints so that slice will get this name

baseQueryUrl: fetchBaseQuery({
    url:'/api';

    It's used to set up the fundamental details of how the API requests are made, such as the base URL, headers, and other options.
})

endpoints: (builder)


Defines the API endpoints using the endpoints property. In this case, there's one endpoint named "register".
builder is an object provided by the library that allows you to define API endpoints and their behavior.

So basically it will call /api/auth/register api which we've already defined to register the user.

and at the end - 
export const {useRegisterMutation} = authApi;

We can use this hook to register the user.

In Redux Toolkit Query, when you define mutations using createApi, the library automatically generates hooks for each mutation endpoint. These generated hooks are prefixed with "use" followed by the name of the mutation endpoint.

-----------

Now we need to add this in store reducer so it'll automatically generate slice.

[authApi.reducerPath] : authApi.reducer

the createApi instance has the reducer in it so we can use it.

--------

middleware

middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat([authApi.middleware]),

    middleware is a configuration option for configureStore. It allows you to customize the middleware that the Redux store uses.

(getDefaultMiddleware) => getDefaultMiddleware().concat([authApi.middleware]) is a function that takes the default middleware provided by Redux Toolkit and appends the middleware from authApi.

authApi.middleware is middleware automatically generated by Redux Toolkit Query when you create an API using createApi. This middleware is responsible for handling API-related actions and side effects, such as making API requests, managing loading states, and updating the store based on API responses.

Redux Toolkit Query takes care of managing this middleware internally.
You don't need to manually write middleware code for each API you create using createApi. The middleware is included as part of the API setup.

--------

Calling hook in component

const [register] = useRegisterMutation();

We are taking register from there.

and calling the register with userData which will be body

register(userData)

And we handled the redirection there.
*/


// Update User controller and route

we'll create controller fot it and get the email and password from the req body and will use findOneByIdAndUpdate()

And we'll create a route for this and will use put method there bcz (mostly we use this for update)


// PROTECT ROUTES WITH UNAUTHENTICATED USERS

we'll create new middleware for this isAuthenticated and in this
1st we'll get the session first to get this next-auth provide 
getToken() - We'll get user in it bcz we've already set it in callbacks of next-auth;
And then we'll check is session there if yes then there is a user in session add that to the request otherwise send the message with 401 status code.

if it is there we'll add that user in request but it'll throw an error property user doesn't exist on NextRequest.

so we'll have to add tha in next.d.ts

And after this in route.ts of update we'll have to use this middleware so we'll use like this:
router.use(isAuthenticated).put(updateDetails)


// UPDATE PROFILE UI
We stored the values in state.
We need current login user name and email to show in that fields so we'll get that from useAppSelector()
bcz we've saved that details in Header.tsx file.
Then
We'll write RTK query to updte the data (The benefits are mentioned above)
And we'll export that fn and we'll call that in UpdateProfile and get that updateProfile fn and will pass the userData to that fn and that fn will make api call to given url in that fn with the data which is body.
And we need to add that in store as well;

and In Redux Toolkit Query (RTK Query), the API slices created using the createApi function provide a way to manage API-related logic, including fetching data, caching, and handling mutations. To make use of these features, you need to integrate the generated API slices into your Redux store.

//There is a one problem now if we update the details then we are not able to see them immediately even though we refresh the page, we've to logout and login again to see them, 
But we don't want that so we've to update the session.


//UPDATE SESSION

1st in [...nextauth] we need to update session in jwt
there wi'll add a check if(request.url.includes("/api/auth/session?update))
then we'll find the updated user in db and set it in the token and then that token's user will be assign to session user.
(we already have user's id in jwt so we'll fetch the data from db. bcz when we've used findOneByIdAndUpdate() it won't return new data it updates in db but doesn't return that.)
Now
We need to write RTK query in usrApi for updateSession() function and that will hit that api "/api/auth/session?update" with update flag.
RTK Query
// We've used lazy there not used useUpdateSessionQuery, If we use lazy and we call that fn useLazyUpdateSessionQuery it will not invoke immediately. If we don't use lazy it will call that fn immediately but don't want that we want to call that fn after updating the user. 

And we'll use that in updateProfile component
  const [updateSession,{data}] = useLazyUpdateSessionQuery();

and in condition of isSuccess in useEffect we'll call this updateSession fn so it'll call that api accordingly and in [...nextauth] it will update the session and in UpdateProfile we've got that user from store and using that. 
and that data will be changed and it'll call the dispatch to update the user in store.


// PROTECT FONTEND ROUTES

We created middleware.ts and in this we define config and in config we pass matcher and in that we passed the path of page which we want to protect.
And we used withAuth middleware by next-auth/middleware

And then if we try to go on /me/update without login it'll redirect us to sign in page and that is provided by next-auth but we want user should be redirect to our custom login page.
so in [...nextauth]/route.ts
in config we'll pass 
pages: {
      signIn: "/login",
    },
    so it'll redirect to /login rather than default page.