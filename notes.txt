By default all components in app directory are server components.
In server components the component is rendered on the server side and the data which is fetched by api is also cached.
Benifits -
Data fetching happens on server side.
Can keep sensitive data on server components like token, api keys.
caching
bundle sizes
initial page load
SEO
streaming.

Static Rendering(Next 13) Replaced with getStaticProps(Next 12)
Dynamic Rendering(Next 13) Replaced with getServerSideProps(Next 12)

By default all the server components are rendered staticly.
Means it will compile the project and cached the data on the server and after that if we request data again it will give cached version rather than fetching data again.

In Dynamic Rendering Routes are rendered for each user at a request time
(Here we prevent caching)



Caching - 

const response = await fetch('http://localhost:3000/api/rooms');

Next js extends native fetch method so we can configure the behaviour of caching and revalidating.
We can fetch data in server components only.

We've done console.log("Rooms per page => ", rooms.resultsPerPage); => output will be Rooms per page 4
Now if we go to controller file in room controller and change the value of resultsPerPage it will not reflect here it will be still 4 because Next JS serving us the cached version of data.

So we are not getting the data dynamically from the backend on each request.

If data doesn't change frequently we can use caching.
If data changes frequently we can override the caching behaviour.


const response = await fetch('http://localhost:3000/api/rooms',{cache:'no-cache'});

What is caching
Caching stores data so it doesn't need to be refetched from backend on every request.
So If next time user makes request the cached data will be return.

By default behaviour is "force-cache"
We can override this using "no-cache" or "no-store"


Revalidation - Revalidation means we clear the cache and fetch the new data.
We can do it in 2 different ways
1. Time-based Revalidation - We specify the time. Eg. After each 10mins refetch the data.

 const response = await fetch('http://localhost:3000/api/rooms',{next:{
    revalidate:10
  }});

  now to see - add console in comp and change the value of resultsPerPage. 
  And if we refresh the page immediately it will still show previous value.
  And if we refresh after 10 seconds 1st time the previous vlaue will come but from 2nd time the new value will come.

  if we pass revaliidate: 0
  In this case it will not store any cache.


2. On-demand Revalidation - When we want to refetch the data. We pass a collection name in it. w'll use if for update room. After updating the room we'll say refetch the data.



// PAGINATION

1. we installed package for pagination.
2. Got the page number from url search params and default it'll be 1.
const searchParams = useSearchParams();
const page = Number(searchParams.get("page")) || 1;
// useSearchParams() -> gives us the url params.
e.g https://google.com?page=3
In this case it will give us {page : 3}
We have pass active page to the <Pagination /> component bcz it need that for active styling.

3. We called this comp in Home Comp and pass the resPerPage and filteredRoomsCount.
// We need to pass this to <Pagination />

3. handleChange function which will be called after changing the page by clicking on the page number; And will have the access to the number which user has clicked.

In this function we want if we click on the page number we want to add that in the query. So we'll use this to fetch the data from backend accordingly.

So 1st we checked window should not be undefined Means page is loaded properly

We can't use the searchParams.set() to set the params we have to use class URLSeaerchParams
We have passed window.location.search to it so  -  it will create a new URLSearchParams object that represents the key-value pairs in the query string.

//Now we want to check if there is a "page" in query then update it with this new page value.
If not set then add it in query
e.g http://localhost:300?page=2 - > already there and user clicks 4 it will be http://localhost:300?page=4
e.g http://localhost:3000 -> not there and user clicks on 2 http://localhost:300?page=2

If the URLSearchParams object is showing { size: 2 } and you've confirmed that your URL is correctly formatted, then it indicates that the forEach loop should work correctly. The { size: 2 } output itself is expected when you log the URLSearchParams object directly, as it doesn't show the individual key-value pairs in the console.
If you want to see you can use forEach method of URLSeaerchParams class.

 we have added the query now we want to push the user to that url.

 const path = `window.location.pathname?${queryParams.toString()}`  - It will convert that to string to show in query.
 and just
 router.push(path);

 Now we want to get the value from query and pass that to backend.
so we are pushing the user to home page bcz the url will be same only params will be change.
In HomePage will get the {searchParams} which will be string and will pass this to the getRoomsData function.

In thw getRoomsData we've again used URLSeaerchParams bcz are getting Object of queryParams - 
{ page: '2' }

and we've passed this so URLSeaerchParams will convert it to query string.
 { 'page' => '2' } 

and that queryString we will convert to actual string so 
page=2

and at the end url will be 
${process.env.API_URL}/api/rooms?page=2 -> And logic for this we've handled in backend


// FILTERS

1. Location 
// We have input field for the location we'll get the value from that field and push that to the url.
// In handleSubmit
We push the user to 
router.push(`/?location=${location}`) so It'll call the api and it will show the data accordingly. We've logic in backend for the same.

Then We updated the code to -  
 // It'll filter out the locations which has no value
        const queryString = [location && `location=${location}`,numOfGuests && `guestCapacity=${numOfGuests}`,roomType && `category=${roomType}`].filter(Boolean).join("&");

So it'll add the queryParams based on the condition.
.filter(Boolean) It will remove all false values.


// REGISTER THE USER - 

1ST we created controller for it and we called that controller in the register api route.

// NEXT AUTH

We called SignIn fn in Login component and that wll come to this file [...nextauth]/route.ts
And it'll see the provider name in this case 'credentials' and will handle it accordingly.


session: and strategy which we will be using for authentication which will be "jwt"

Now there are providers array in this we define what type of providers we will be using 
e.g Github 
google
instagram etc 
and we are using CredentialsProvider

in CredentialsProvider we have authorize function in this we get the access to credentials.
so we destructed the email and password of the user to check in db is that user is present or not.

After this we returned the user;

Callbacks.

Now we have some callbacks in nextAuth 
Callbacks are asynchfonous functions we can use to control what happens when action is performed.

// We've to add the user in the session. so will use some callbacks e.g jwt and session

jwt: async({token,user}) => {
            if(user) {
                token.user = user;
            }

            // TODO : Update session when user is updated.
            return token;
        },
this callback is called when JWT is created or updated.
in this fn we get the access to token and the user which we are returning from authorize();

Now we want to store the user in session so we'll write the session callback in that we'll get the session and the token which we are returning from the jwt.

session: async({session,token}) => {
            session.user = token.user as IUser;

            return session;
        }

        We have stored the user in token already in jwt callback so we are saving the user in session.user as well.

// And at the end we added secret key 


// Showing username in header

So we'll get user session and in that we'll have user details and we'll show it in header.

1st we need to wrap our application in SessionProvider so we did that in Global provider

then in header we'll use useSession hook to get the session. 
And when we wrap our app in session provider it'll also call the session callback in [...nextauth]/route.ts

// Logout 
for logout nextauth provoides us signOut() functoijn we can call that to signout.

//Skeleton on loading

If we refresh the page the data which is coming from session will be undefined, and once session is loaded the data will have the user value.
so we want to show the skeleton if data is undefined.

//Redux toolkit query
1st Create a store using configureStore();
Wrap the application using Provider.
create custom hooks for useDispatch and useSelector. 
// * @use - Using these custom hooks avoids repeating type definitions for useDispatch and useSelector in multiple places.


//Slices
//Slice - Slice is a collection of your reducer logic and actions.

//We created userSlice 
and in this we defined initial state for the user slice and also reducers
setUser and setIsAuthenticated
We'll dispatch this and it'll updated our state.

We've exorted reducer bcz we want to use that in store and in store we have given the name to it 'auth'.
And whenever we need user data we'll call useSelector() and take state.auth so it'll give the user data.
And also exported dispatch to dispatch the actions.
And we've set the user in header.tsx


// Redux toolkit query
This is used to get the data and to cache the data but we are not using this feature of the RTK query, we'll use it to register the user.

If we want to send the data to backend means POST request then we use Mutation
And If we want to get the data we use query


// Using Redux Toolkit Query and creating an API with createApi provides several benefits even if you can directly call the register API. Here are some reasons why you might want to use it:

// Redux Integration: It seamlessly integrates with Redux, allowing you to store API data in the Redux store. This makes it easy to manage and share data across components.
Means - When you make an API call, RTK Query handles the response and automatically stores the data in the Redux store.
For example, when you call register(data), RTK Query will manage the API request, receive the response, and store relevant data in the Redux store.

// State Management: Redux Toolkit Query handles the caching, invalidation, and re-fetching of data for you. This can significantly simplify the state management of your application.

// Slices: It automatically creates Redux slices for your API endpoints, reducing the need for manually writing actions, reducers, and selectors.

// Normalization: It normalizes data by default, making it easy to update parts of your Redux store without duplicating data.

// Generated Hooks: It generates hooks for each endpoint, like useRegisterMutation in your case. These hooks handle dispatching actions and managing loading states.

// Consistency and Convention: It follows conventions and best practices, promoting a consistent and organized approach to handling API requests.

// Middleware: It allows you to add middleware, such as authentication checks, easily

/* We used createApi to create api,  
reducerPath: "authApi", RTK query automatically creates slices for api endpoiints so that slice will get this name

baseQueryUrl: fetchBaseQuery({
    url:'/api';

    It's used to set up the fundamental details of how the API requests are made, such as the base URL, headers, and other options.
})

endpoints: (builder)


Defines the API endpoints using the endpoints property. In this case, there's one endpoint named "register".
builder is an object provided by the library that allows you to define API endpoints and their behavior.

So basically it will call /api/auth/register api which we've already defined to register the user.

and at the end - 
export const {useRegisterMutation} = authApi;

We can use this hook to register the user.

In Redux Toolkit Query, when you define mutations using createApi, the library automatically generates hooks for each mutation endpoint. These generated hooks are prefixed with "use" followed by the name of the mutation endpoint.

-----------

Now we need to add this in store reducer so it'll automatically generate slice.

[authApi.reducerPath] : authApi.reducer

the createApi instance has the reducer in it so we can use it.

--------

middleware

middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat([authApi.middleware]),

    middleware is a configuration option for configureStore. It allows you to customize the middleware that the Redux store uses.

(getDefaultMiddleware) => getDefaultMiddleware().concat([authApi.middleware]) is a function that takes the default middleware provided by Redux Toolkit and appends the middleware from authApi.

authApi.middleware is middleware automatically generated by Redux Toolkit Query when you create an API using createApi. This middleware is responsible for handling API-related actions and side effects, such as making API requests, managing loading states, and updating the store based on API responses.

Redux Toolkit Query takes care of managing this middleware internally.
You don't need to manually write middleware code for each API you create using createApi. The middleware is included as part of the API setup.

--------

Calling hook in component

const [register] = useRegisterMutation();

We are taking register from there.

and calling the register with userData which will be body

register(userData)

And we handled the redirection there.
*/


// Update User controller and route

we'll create controller fot it and get the email and password from the req body and will use findOneByIdAndUpdate()

And we'll create a route for this and will use put method there bcz (mostly we use this for update)


// PROTECT ROUTES WITH UNAUTHENTICATED USERS

we'll create new middleware for this isAuthenticated and in this
1st we'll get the session first to get this next-auth provide 
getToken() - We'll get user in it bcz we've already set it in callbacks of next-auth;
And then we'll check is session there if yes then there is a user in session add that to the request otherwise send the message with 401 status code.

if it is there we'll add that user in request but it'll throw an error property user doesn't exist on NextRequest.

so we'll have to add tha in next.d.ts

And after this in route.ts of update we'll have to use this middleware so we'll use like this:
router.use(isAuthenticated).put(updateDetails)


// UPDATE PROFILE UI
We stored the values in state.
We need current login user name and email to show in that fields so we'll get that from useAppSelector()
bcz we've saved that details in Header.tsx file.
Then
We'll write RTK query to updte the data (The benefits are mentioned above)
And we'll export that fn and we'll call that in UpdateProfile and get that updateProfile fn and will pass the userData to that fn and that fn will make api call to given url in that fn with the data which is body.
And we need to add that in store as well;

and In Redux Toolkit Query (RTK Query), the API slices created using the createApi function provide a way to manage API-related logic, including fetching data, caching, and handling mutations. To make use of these features, you need to integrate the generated API slices into your Redux store.

//There is a one problem now if we update the details then we are not able to see them immediately even though we refresh the page, we've to logout and login again to see them, 
But we don't want that so we've to update the session.


//UPDATE SESSION

1st in [...nextauth] we need to update session in jwt
there wi'll add a check if(request.url.includes("/api/auth/session?update))
then we'll find the updated user in db and set it in the token and then that token's user will be assign to session user.
(we already have user's id in jwt so we'll fetch the data from db. bcz when we've used findOneByIdAndUpdate() it won't return new data it updates in db but doesn't return that.)
Now
We need to write RTK query in usrApi for updateSession() function and that will hit that api "/api/auth/session?update" with update flag.
RTK Query
// We've used lazy there not used useUpdateSessionQuery, If we use lazy and we call that fn useLazyUpdateSessionQuery it will not invoke immediately. If we don't use lazy it will call that fn immediately but don't want that we want to call that fn after updating the user. 

And we'll use that in updateProfile component
  const [updateSession,{data}] = useLazyUpdateSessionQuery();

and in condition of isSuccess in useEffect we'll call this updateSession fn so it'll call that api accordingly and in [...nextauth] it will update the session and in UpdateProfile we've got that user from store and using that. 
and that data will be changed and it'll call the dispatch to update the user in store.


// PROTECT FONTEND ROUTES

We created middleware.ts and in this we define config and in config we pass matcher and in that we passed the path of page which we want to protect.
And we used withAuth middleware by next-auth/middleware

And then if we try to go on /me/update without login it'll redirect us to sign in page and that is provided by next-auth but we want user should be redirect to our custom login page.
so in [...nextauth]/route.ts
in config we'll pass 
pages: {
      signIn: "/login",
    },
    so it'll redirect to /login rather than default page.



// NESTED LAYOUT FOR USER PROFILE

We've created nested layout.tsx In /me so Whatever call we do like 
/me/update
/me/update-password
/me/forgot-password

That will pass to the layout as a children (Not sure) and we are Rendering that.

// UPDATE PASSWORD API ROUTE
// 1st we created controller and we got user written password.
// Then in UserModel we'll add our own method in userSchema, and we can use that later whenever we want.
// In that we'll compare the password and return boolean based on the result.
// And in updatePassword controller we'll use this.
// And will check there if it is not matched then throw new error.
// Otherwise update it in db using save(), so whenever we'll use save() on user the fn which we've in Usermodel userSchema.pre will execute and it will encrypt that password before saving it in db.

//UPDATE PASSWORD
So we'll update the user password
1st create the Mutation for the same updatePassword
then create components for that
and store the passwords in state.
and call the useUpdatePasswordMutatin() to get updatePassword and call that in form handler.
and handle error success and etc.. states in useEffect.


//CLOUDINARY
create account on CLOUDINARY.
and set up it in backend / utils /cloudinary.ts

and created a function there to upload a file and delete a file


// UPLOAD AVATAR 
1st create controller.
Create route for this and handle request there and call this middleware with put request.

//UPLOAD AVATAR UI
created comp 
and we'll have 2 states there 1 to send the new image to backend and another for preview.
And need there user to show the avatar if user already has.

And in onChange we got all files using e.target.files adn used Array.from()
The Array.from() static method creates a new, shallow-copied Array instance from an iterable or array-like object.

And now we need fileReader to read the file and display in preview.

And then we check is readyState 2 means file is ready we'll set in avatar and preview.

and then we'll call reader.readAsDataURL(files[0]); And when it will complete then it will triggered onload.
so it'll read that file and then it'll set it.
// Cloudinary not working properly, we'll figure it out later

//MENU SIDEBAR BUG 
If we are on updateProfile page and we go on updatePassword the updatePassword link will be active but if we refresh the page we'll be on updatePassword but the updateProfile link will be active to fixed this bug.
we are taking the url from url and then adding condition on it.

// ******************************************

FORGOT PASSWORD AND RESET PASSWORD

If user forgot the password we'll allow user to send the email to reset it.
we've   resetPasswordToken: String,
  resetPasswordExpire: Date, 
  In model 
  so we'll generate the token and store it in resetPasswordToken. 
  and we'll store expire time in resetPasswordExpire which will be 30mins.
// So user can reset the password with this token within 30mins.
WE'LL use crypto package for this. It is inbuilt package in node js.

//Generating the token
userSchema.methods.getResetPasswordToken = function() {
  //generating token
  *** const resetoken = crypto.randomBytes(20).toString('hex');

  crypto.randomBytes will generate buffer of 20 random bytes.
  It would look like 
  Buffer: <Buffer 8d a4 3f 91 2c 6e 5a 9b a7 7d> // 10 bytes buffer
  and then we are converting it to hexadecimal string.
  so it would look like
  Hexadecimal Value: 8da43f912c6e5a9ba77d

  Now we need to hash it for security purpose.
  
  this.resetPasswordToken = crypto.createHash('sha256').update(resetToken).digest('hex');

  crypto.createHash('sha256') => Creates a new hash object using the SHA-256 algorithm from the crypto module in Node.js.

  .update(resetToken) => It needs to convert into hash.
  
  .digest('hex') => generates the hash in hex format. (Converts the binary hash into a human-readable string of hexadecimal characters).


// Now we need to set token expiry date 
this.resetPasswordExpire = Date.now() + 30 * 60 * 1000;
30mins * 60sec * 1000ml
Result: 1,800,000 milliseconds, which is equivalent to 30 minutes.

return resetToken;
//we'll send this token to user's email.
}


//SETUP NODEMAILER AND EMAIL HTML TEMPLATE
1ST sign up on mailtrap

we'll get creds and api keys there if we select nodemailer in integration.
now we need to install nodemailer.
npm i nodemailer

create a file in backend/utils sendEmail.ts
in that create a fn and we'll call this fn from controller with the data email , subject and message
Now set the values in .env
and create a transport.
and create a message like - from yash <bookit.......com>
and use transport.sendEmail(message) to send the mail to user.

Now we need to create a email template which user will see.
so in utils we'll create new file emailTemplate.ts
and there will add the html code.

And we'll use that in SendEmail

// RESET PASSWORD RECOVERY EMAIL
1st we'll create controller for this and then we'll create api endpoint

in controller 1st we'll find that user with email entered by user.
if user isn't there in db we'll throw error. 
if user is there we'll get the token and do use.save()

 now we need to create url and message to pass it to get emailhtmltemplate
so 
/ url where user will redirect
const requestUrl = `${process.env.API_URL}/password/reset/${resetPasswordToken}`

const message = resetPasswordHTMLTemplate(user.name,requestUrl)

and we'll call sendEmail fn and pass the values accordingly

and if it fails we'll again set the token undefined and expire time undefined in db.

then we need to send email.

Don't fogot to update the mailtrap password with actual password.


//FORGOT PASSWORD COMPONENT
create mutation for this in authApi and then use That hook in forgotPassword comp and call it onSubmit;

// RESET PASSWORD endpoint
1st create controller 
in that we'll get the token from url 
params :{ token}  like this

and then we'll use same code to hash this token again;
this time we'll pass the token which is in url to match with the token which is in db.

so we'll find the user in db with reset passwrod token. And we'll also check is that token expired. using mongoose operators
  const resetPasswordToken = crypto
    .createHash("sha256")
    .update(params.token)
    .digest("hex");
    const user = await User.findOne({
      resetPasswordToken,
      resetPasswordExpire: {$gt: Date.now()}
    })
gt means greater than so it will check is that expire time is greater than current or not, bcz we've set 30 mins time there in db means 30 mins after reset link.

And if user is not there we'll throw an error.
if both passwords not match we'll throw an error
if everything is fine we'll set the password as a password  and resetPasswordToken and resetPasswordExpire to undefined.

In getResetPasswordToken() 1st we generate the token and then we created hash for that and stored that hash in db and return generated token not hash.
And in url we psased generated token not hash.
So when user will click on btn to reset the generated token will be there in url not hash token.
And when we reset the password we'll get that generated token from params and hash that to match with hashed token in db.


// RESET PASSWORD COMPONENT
1st create component 
create mutation call the mutation fn in component in submit handler.
and it'll handle that.





// BOOKING model
create the schema and export it model
We've used ref there in room and in user so 
room is of type mongoose.Types.ObjectId, indicating that it should be an ObjectId. The ref property specifies that it refers to the "Room" model.


// Booking Date picker
Install - npm install react-datepicker --save
We can see all the available datepickers here - https://reactdatepicker.com/

import the css for the datepicker from dist .....
that datepicker takes some props 
        selected= selected date we can give today's date.
        onChange={handleDateChange}
        startDate= if we give today's date the previous dates will be disabled.
        endDate= end date
        selectRange - we can select date in range
        inline - we can see the calender of selected date if this prop isn't there we'll see selcted date in input box.



// ADDING NEW BOOKING

Created the controller
we defined endpoint
we created mutation
added reducer of this in store
used mutation in frontend


//CHECK ROOM AVAILABILITY
1st we'll get the roomId, checkInDate, checkoutDate from url .

And we've added condition there 
 const bookings: IBooking[] = await Booking.find({

    room:roomId,
    $and : [
      {checkInDate : {$lte : checkoutDate}},
      {checkoutDae: {$gte: checkInDate}}
    ]
  });

  // It 1st we find by room id and then 
  checkInDate in DB should be less than checkoutDate which is in query.
  And 
  checkoutDate in DB shold be greater than checkInDate which is in query.

  It will return the rooms if there are this condition satisfied means rooms are already book.

  // CHECKING ROOM AVAILABILITY ON FRONTEND.
  create a endpoint in redux query then in url we'll pass roomId, checkInDate, and checkoutDate. and we'll get this in backend to check availability.

  And export this endpoint as lazy because we want to call this once user selects the date.
  checkBookingAvailability
  use

  now in roomDatepicker
  get this using useLazyCheckBookingAvailabilityQuery
  and we'll pass this to query to pass it to backend

  And in RoomBookingDatePicker call this fn in onChange so we'll know the availability on change of date and we'll show the message accordingly.

  We've condition there checkoutDate && .... 
and inside this isAvailable 
-checout Is for we don't want to show that availabilty message before we select the date.


// GET BOOKED ROOM DATES
1st get the roomId from the query.
then find the all bookings with that room Id.

then use moment-range package to get the dates between checkindate and checkout date.
e.g we've booking from 10 to 15
so it'll give us the 5 dates.
And we want that in array so we used Array.from()
It'll push the date one by one in that array and at the end it will return the array.
And to converting a multi-dimensional array or an array of arrays into a one-dimensional array. 
We want the diff between 'day' so we used 'day'.

// DISABLED ALL THE DATES ON FRONTEND CALENDER
1st create a query for this. and pass a room Id in url.

Now in RoomBookingDatePicker component get the dates from backend 

cosnt {data:{bookedDates}} = useGetBooked.....(room._id);

now we'll get all the book dates. this date will be in string format. 
We want each date in Date format to pass it to DatePicker to disbaled this.

so we'll pass this dates to datePicker excludeDates={excludeDates}

We've to use .add(1,"day") there in controller bcz we also want to disable checkout date which is in db. before it was not giving the checkout date so it was not disabling.


//GET CURRENT USER BOOKINGS
Create a controller to find the bookings with user id which is in req. we've set the user in request when we check for authentication.
and then return the bookings.

//GET BOOKING DETAILS
Create a controller to get the booking details with given booking id.
And create a route for this in api 
/api/bookings/:id
and in the controller we'll get this slug, to find the booking with this id.

//GET CURRENT USER BOOKINGS
Create a component in components and uesr MDBData table package to show the bookings in table.
It has features like pagination, search , sort and etc..

Now we've to create columns and rows for the table.
so we'll create a fn setBookings and in this fn we'll set the columns and row and return those.

Now create the columns with the lable, field and sort order.
label will display in head of table,
id need to associate to the row of table
and sort is for sorting order

so we'll add the objects in columns array. 
and for rows we'll map through the all bookings and we'll push the data in row one by one.
keys should be same as we have given field in coulumns
push({
  id:booking._id,
  checkin:Date(booking.checkInDate).toLocalString('en-us');
  and so on
})


And now in app create a folder bookings and in that we'll create a folder me.
In that call this compo MyBookings.
In this page we'll call the api to get all the bookings and we'll pass this to the MyBookings component.

And the api to get the current user's bookings is protected so we need to pass the cookies in headers.
so we'll pass 
headers :{
  Cookie: 'next-auth.session-token=enter token which is in cookie
}

And we also want to protect the bookings route on frontend so add this in middleware .ts

Now in MyBookings we'll get the bookings so we'll just create a columns and rows and pass it to the MDBDatatable
so fo the columns we need to pass the label , id and the sort for each column.
And for the row we mapped through the booking and set the data for each row.
And in rows for each row we've also created the action so we can perform on each row.


//CREATE A FUNCTION TO GET A COOKIE WE WON'T HARD CODE IT IN URL
create a file in Helpers -> authHeader.ts

in that we'll get the cookie from the browser's cookies

using cookies() of next/headers
so we'll get all the cookies but here we want 'next-auth.session-token' so we'll get that 
const nextCookies = cookies();
const nextAuthSessionToken = nextCookies.get('next-auth.session-token');

but there is an issue with it the cookie name on the production will be different.
so we've to check that 

we'll create a fn to check that, in that fn
process.env === 'production' ? '__Secure-next-auth.session-token' : 'next-auth.session-token'

const cookieName = call the above fn
const nextAuthSessionToken = nextCookies.get(cookieName);
const 
and at the end we'll return 
{
  headers: {
    Cookie: `${nextAuthSessionToken.name}=${nextAuthSessionToken.value},
  }
}

WE'VE REMOVED NO-CACHE, IT WON'T GOING TO WORK IF WE USER COOKIES FETCH REQUESTS ARE NOT CACHED IF - THE FETCH REQUEST COMES AFTER THE USAGE OF HEADERS OR COOKIES.


//BOOKING DETAILS PAGE 
Get the booking in BookingDetailsPage and pass that to BookingDetailsComponent.
And display booking details there.

Now we are getting only user id in user of booking but we want the user details to display here so in getBookingDetails controller we'll populate('user')
when we find the booking
And also we want room details so we'll pupulate that as well.
populate('user room');
And show there in booking details page.


//BOOKING INVOICE
1st create component Invoice and then create page for this in app and call this component there, fetch the room details there in page and pass it to this component.

Populate it with all the values.

To download the invoice we'll use 2 packages
html2canvas - It allows us to take a screenshot of a webpage. So we'll take the screenshot of the div of invoice by selecting it by id.

jsPDF - Once we got the screenshot using html2canvas we'll convert that to pdf using this and then save it in the system.

1st we'll get that div whose screenshot we wanna take.
const elementToBeCaptured = document.getElementById('booking_invoice');

then we'll call the html2canvas fn and that will return the promise with the screenshot.
Then we've used .toDaaURL('image/png')
So it returns the content of the current canvas image and we pass the type we want.
to tell type of img.

Now we've to add the image in pdf
so we'll create the instance of jsPDF()
const pdf = new jsPDF();
now we want to specify the width of the pdf so
const pdfWidth = pdf.internal.pageSize.getWidth();
so we'll get the width of the pdf
And now we have to add that image in pdf.
so 
pdf.addImage(imageDate,0,0,pdfWidth,0);
And then we want to save that in machine 
so 
pdf.save('invoice_${booking._id}.pdf')

add image takes - addImage(imageData, format, x, y, width, height, alias, compression, rotation)

Blog on jspdf
https://www.michaelmarino.dev/blog/jspdf/
https://artskydj.github.io/jsPDF/docs/module-addImage.html


// PAYMENT INTEGRATION
USE RAZORPAY DUMMY PAYMENT INTEGRATION
We can't use env variables in client side component, otherwise our sensitive information might be leak, like api keys and etc, 
But if we have something that is not sensitive but we want to store that in env and want to use that on client component then we can define like this 
NEXT_PUBLIC_RAZORPAY_KEY="KEY"


//ADD ROOM REVIEW
1st get the rating comment and roomId from the body 
create a review object 
find that room in db.
check is user has already given review on that room if yes then update the previous review with new one.
If not add this in review.
We also want to get the average of reviews rating to display on frontend.
and then save the room.


//ADD REVIEW FROM FRONTEND

1st create a mutation and in redux store
have a states for review comment and rating in review modal


//DISPLAY ALL reviews
display reviews on frontend get this from backend


//If USER HAS NOT BOOK PARTICULAR ROOM USER CAN'T ADD REVIEW ON THAT ROOM.

create new controller for the same
In that we'll get the roomId from the query.
And userId from the request and we'll check in booking
if there is any booking with this user id and room
if yes then we we'll allow user to give the review.

Then create endpoint 

Then create query in redux

and call this in newReviewModal.

//ADMIN ROUTES
//Create admin SIDEBAR like user sidebar but admin will have some more access.
Create layout in admin like we've in me


//PROTECT ROUTES 
IF USER IS NOT ADMIN HE CAN'T ACCESS ADMIN ROUTES ON BACKEND AND ON FRONTEND

1st on backend
In backend we've middleware files there we'll create new middleware.
We are taking the roles who can access the route and checking if the current user role is include in that or not if yes then next() to go ahead otherwise return errorMessage.

to use this we've to do.
router.use(isAuthenticated,authorizeRoles("admin")).get ....
In this case only admin can access this api endpoint.
User should be authenticated 1st, bcz there we are setting the user in request.
check this like 
localhost:3000/api/rooms
This check is only for backend route.

//ADMIN MIDDLEWARE ON FRONTEND
in middleware.ts
we'll check if url starts with '/admin' and current user role is not the admin we'll redirect user to '/'

Then we'll use callbacks to check is user authorized or not
so 
authorized: ({ token }) => !!token,
It will check is token there if yes return true and if not return false.
And also added in matcher.


DISPLAY CONTENT ON DASHBOARD
There we'll give the option to select start date and end date and fetch the sales between this days and display.
1st add date pickers to select the dates.
2nd add the container to show the data.
Then we'll show 2 charts 
1. To show the sales of 6 months.
2. To show top performing rooms


//SHOW TOTAL SALES AND TOTAL BOOKINGS ON DASHBOARD
we've given 2 datepickers to select the start and end date. so user will get the booking which are done in this days.

1st we will create controller in bookingController getSalesStats.
In this controller 1st we'll have to get the currentDate and endDate.
so we'll get that from searchParams bcz we'll add that in api when we call that api in redux toolkit query.

Then in controller we'll set the hours in start date and end date, because start date's hours will start from 0 0 0 0 and end dates' hours will be till 23 hrs 59 minutes to get the whole day booking.

Then we'll add condition to get the bookings 
so createdAt should be greater than start date and less than end date.

Then create the router for the same.

Now create the rtk query for the same. And export then lazy function.

Now we'll call this lazy in dashboard and get the data there and pass this date to SalesStats.
But initially we will display the todays bookings only.
so we'll call that initial api in useEffect.
!data is for bcz if data is there we don't wanna call this.
if(startDate && endDate && !data) {
  call that fn to get the todays data.
}

And pass this data to SalesStats to display